<!doctype html>
<html lang="en" data-kind="post" data-slug="rust-ffi-c-without-footguns" data-title="Rust FFI Into C Without Footguns" data-summary="A pragmatic checklist for ABI-safe Rust/C boundaries: ownership, lifetime transfer, and panics across FFI." data-image="assets/images/rust-ffi-c-without-footguns.jpg" data-time-min="11" data-category="systems" data-tags="rust,c,ffi,safety" data-published="2026-02-21">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Rust FFI Into C Without Footguns</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;700&family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet">
  </head>
  <body class="min-h-screen bg-[#050805] font-['IBM_Plex_Mono'] text-[#b8ffc6]">
    <div class="pointer-events-none fixed inset-0 opacity-35" style="background-image: linear-gradient(rgba(30, 95, 40, 0.35) 1px, transparent 1px), linear-gradient(90deg, rgba(30, 95, 40, 0.35) 1px, transparent 1px); background-size: 30px 30px;"></div>

    <def-blog-header>
      <header class="sticky top-0 z-20 border-b border-[#1f5f2a] bg-[#040704]/90 backdrop-blur">
        <div class="mx-auto flex max-w-6xl items-center justify-between px-6 py-4">
          <a href="../index.html" class="font-['Space_Grotesk'] text-2xl font-bold uppercase tracking-[0.12em] text-[#8dff9e]">Ami//Devlog</a>
          <nav class="flex items-center gap-6 text-sm font-semibold uppercase tracking-[0.09em] text-[#9de8a8]">
            <a class="hover:text-[#d8ffe0]" href="../index.html">Posts</a>
            <a class="hover:text-[#d8ffe0]" href="../about.html">About</a>
          </nav>
        </div>
      </header>
    </def-blog-header>

    <def-post-shell>
      <blog-header></blog-header>
      <div class="mx-auto max-w-5xl px-6 py-8 md:py-10">
        <article class="border border-[#2b713a] bg-[#061006] p-6 md:p-10">
          <header>
            <p class="text-[11px] uppercase tracking-[0.17em] text-[#7cd88f]"><bind name="date"></bind> Â· <bind name="read" default="quick read"></bind></p>
            <h1 class="mt-2 font-['Space_Grotesk'] text-4xl font-bold uppercase leading-tight text-[#dcffe2] md:text-5xl"><bind name="title"></bind></h1>
            <p class="mt-4 max-w-4xl text-sm leading-7 text-[#a3ebb1]"><bind name="dek" default=""></bind></p>
          </header>
          <div class="mt-8 space-y-6 text-sm leading-7 text-[#b5f9c2]"><slot></slot></div>
          <section class="mt-10 border-t border-[#215c2e] pt-5 text-sm text-[#9fe0ab]"><slot name="afterword"></slot></section>
        </article>
      </div>
    </def-post-shell>

    <def-callout>
      <aside class="border border-[#2f8742] bg-[#081408] p-4 text-[#b9ffca]">
        <p class="text-xs font-semibold uppercase tracking-[0.12em] text-[#7ae88f]"><bind name="title" default="Field note"></bind></p>
        <p class="mt-2 text-sm leading-7"><slot></slot></p>
      </aside>
    </def-callout>

    <post-shell title="Rust FFI Into C Without Footguns" date="February 21, 2026" read="11 min" dek="Rust and C can cooperate safely, but only if ownership and ABI boundaries are treated like protocol contracts.">
      <img src="../assets/images/rust-ffi-c-without-footguns.jpg" alt="Rust programming language logo" class="w-full border border-[#2a6f3a] bg-[#081208] object-cover">

      <p>Every FFI boundary is a trust boundary. C will trust your pointer discipline; Rust will trust your `unsafe` blocks. If either side lies, the crash arrives far from the bug. The fastest way to avoid that class of failure is to define explicit transfer semantics for every function: who allocates, who frees, and when ownership changes hands.</p>
      <p>I keep C-facing APIs tiny and boring: primitive types, explicit lengths, no hidden global state, no callbacks unless absolutely necessary. On the Rust side, wrappers translate rich types to flat ABI-safe structures before crossing the line. This keeps undefined behavior localized instead of contagious.</p>

      <h2 class="font-['Space_Grotesk'] text-2xl font-bold uppercase text-[#d5ffde]">The checklist that catches most bugs</h2>
      <ul class="list-disc space-y-2 pl-6">
        <li>Mark all exported functions with stable calling convention and symbol visibility.</li>
        <li>Never unwind across FFI. Convert panics to error codes at boundary points.</li>
        <li>Treat `char*` as `(ptr, len)` whenever binary or non-UTF-8 data is possible.</li>
        <li>Pair alloc/free functions and document them as a strict contract.</li>
      </ul>

      <callout title="Rule of thumb">
        If you cannot explain lifetime ownership in one sentence for a function, redesign the function.
      </callout>

      <p>Once the boundary becomes a protocol, testing gets easier. I build tiny C harnesses and Rust integration tests that call each function repeatedly with edge sizes, null pointers, and malformed lengths. The goal is not elegance; the goal is mechanical confidence.</p>

      <div slot="afterword">Next dispatch: <a class="font-semibold underline hover:text-[#deffe4]" href="c-byte-level-profiling-notes.html">C Byte-Level Profiling Notes</a>.</div>
    </post-shell>
  </body>
</html>
